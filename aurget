#!/bin/bash
#
# pbrisbin 2013
#
###
AUR='https://aur.archlinux.org'

# Help message {{{
message() {
  cat << EOF
Usage: aurget [ -h | -S* [ --options ] [ -- ] <arguments> ]

  Options:

        -S  <package>   process <package> using your default sync_mode

        -Sd <package>   download <package>
        -Sb <package>   download and build <package>
        -Sy <package>   download, build, and install <package>

        -Su             process available upgrades using your default sync_mode

        -Sdu            download available upgrades
        -Sbu            download and build available upgrades
        -Syu            download, build, and install available upgrades

        -Ss  <term>     search aur for <term>
        -Ssq <term>     search aur for <term>, print only package names
        -Sp  <package>  print the PKGBUILD for <package>
        -Si  <package>  print extended info for <package>

        --devel         only affects -Su, add all development packages

        --deps          resolve dependencies
        --nodeps        don't resolve dependencies

        --edit          prompt to edit all pkgbuilds
        --noedit        don't prompt to edit any pkgbuilds

        --discard       discard source files after building
        --nodiscard     don't discard source files after building

        --nocolor       disable coloring

        --noconfirm     auto-answer all prompts

        --ignore <package>
                        add additional packages to be ignored

        --config <file> source <file> for user configuration

        -h, --help      display this

  Any unrecognized options will be passed directly to makepkg.

EOF
}
# }}}

# Support {{{
die() { error $*; exit 1; }

info() { printf "${colorB}:: $colorW$*$nocolor\n"; }

warn() { printf "${colorY}warning:$nocolor $*\n" >&2; }

error() { printf "${colorR}error:$nocolor $*\n" >&2; }

debug() {
  $debug && printf "$colorW[${colorC}DEBUG$colorW]$nocolor $*\n" >&2
}

# thanks Irm
url_encode() {
  hexdump -v -e '1/1 "%02x\t"' -e '1/1 "%_c\n"' <<< "$*" \
    | LANG=C awk '
      $1 == "20"                   { printf("%s", "+"); next }
      $1 ~  /0[adAD]/              {                    next }
      $2 ~  /^[a-zA-Z0-9.*()\/-]$/ { printf("%s", $2);  next }
                                   { printf("%%%s", $1)      }
    '
}

aur_packages_url() {
  printf "$AUR/packages/$(url_encode "${1:0:2}")/$(url_encode "$1")\n"
}

aur_search_url() {
  printf "$AUR/rpc.php?type=search&arg=$(url_encode "$1")\n"
}

aur_info_url() {
  local params='' arg

  for arg; do
    params+="&arg\[\]=$(url_encode "$arg")"
  done

  printf "$AUR/rpc.php?type=multiinfo$params\n"
}

get() { debug "HTTP GET $colorM$1$nocolor"; curl --silent --fail "$1"; }

pkgbuild() { get "$(aur_packages_url $1)/PKGBUILD"; }

taurball() { get "$(aur_packages_url $1)/${1}.tar.gz"; }

rpc_search() { get "$(aur_search_url "$1")" | parse_rpc; }

rpc_info() { get "$(aur_info_url "$@")" | parse_rpc; }

parse_rpc() {
  awk -F '[^\\\\]"' -v RS='{"|,"|"}' '
    function unstring(str) {
      sub(/[^:]+:/, ""  , str) # remove prefix
      gsub(/\\\"/ , "\"", str) # un-escape quotes
      gsub(/\\\// , "/" , str) # un-escape urls
      gsub(/%/    , "%%", str) # escape percents for printf
      gsub(/\|/   , "/" , str) # replace pipe (our own field sep)
      gsub(/"$/   , ""  , str) # remove extra trailing quote

      return substr(str, 2, length(str)) # unquote value
    }

    /Name":/        { printf "%s",    unstring($0) }
    /Version":/     { printf "|%s",   unstring($0) }
    /Description":/ { printf "|%s",   unstring($0) }
    /URL":/         { printf "|%s",   unstring($0) }
    /OutOfDate":/   { printf "|%s",   unstring($0) }
    /URLPath":/     { printf "|%s\n", unstring($0) }
  '
}

is_devel() { [[ "$1" =~ -(git|hg|svn|darcs|csv|bzr)$ ]]; }

is_ignored() { [[ " $ignore_packages " =~ " $1 " ]]; }

buildpkg() {
  debug "executing $colorY$makepkg $makepkg_options $@$nocolor"

  if $silent; then
    $makepkg $makepkg_options "$@" --noconfirm &>/dev/null
  else
    $makepkg $makepkg_options "$@"
  fi
}

prompt() {
  local a

  printf "$*? [Y/n] "

  $noconfirm && { printf "Y\n"; return 0; }

  read a

  case "${a:-y}" in
    y|Y) return 0      ;;
    q|Q) die 'aborted' ;;
    *)   return 1      ;;
  esac
}

prompt_to_edit() {
  local name="$1" pkgbuild="$2"; shift 2
  local action="${*:-sourcing for dependencies}"

  case "${edit_pkgbuilds:-prompt}" in
    never)  return 0 ;;
    prompt) prompt "Edit $name's PKGBUILD before $action" || return 0 ;;
  esac

  debug "executing $colorY$EDITOR $pkgbuild$nocolor"

  $EDITOR "$pkgbuild" || die "editor returned non-zero ($?), aborting"

  prompt "Continue $action"
}

prompt_to_install() {
  local name

  printf "\n${colorY}Targets ($#):$nocolor "

  for name; do
    printf "${name}-${target_versions[$name]} "
  done

  printf "\n\n"

  prompt "Proceed with installation" || exit 0
}

nothing_to_do() {
  printf " there is nothing to do\n"
  exit 0
}
# }}}

# Initialization {{{
set_defaults() {
  local config_regex=' --config +([^ ]+) '

  debug=false
  user_config="${XDG_CONFIG_HOME:-$HOME/.config}/aurgetrc"

  [[ " $* " =~ " --debug "    ]] && debug=true
  [[ " $* " =~ $config_regex  ]] && user_config="${BASH_REMATCH[1]}"

  build_directory="$PWD"
  devels=false
  discard_sources=true
  ignore_packages=''
  keep_devels=true
  makepkg='makepkg'
  makepkg_options='--syncdeps'
  noconfirm=false
  opmode='install'
  resolve_dependencies=false
  search_mode='search'
  silent=false
  sync_mode='install'
  temp_directory='/tmp/aurget'

  EDITOR="${EDITOR:-$VISUAL}"
  EDITOR="${EDITOR:-vi}"

  if [[ -t 1 ]]; then
    colorR="\e[1;31m"
    colorG="\e[1;32m"
    colorY="\e[1;33m"
    colorB="\e[1;34m"
    colorM="\e[1;35m"
    colorC="\e[1;36m"
    colorW="\e[1;37m"
    nocolor="\e[0m"
  fi
}

source_config() {
  if [[ -r "$user_config" ]]; then
    debug "sourcing user configuration from $colorM$user_config$nocolor"
    source "$user_config"
  fi
}

set_no_color() {
  colorR=''
  colorG=''
  colorY=''
  colorB=''
  colorM=''
  colorC=''
  colorW=''
  nocolor=''

  makepkg_options+=' --nocolor'
}

parse_options() {
  while [[ -n "$1" ]]; do
    case "$1" in
      -S)            opmode='install'                                ;;
      -Sy)           opmode='install'; sync_mode='install'           ;;
      -Sb)           opmode='install'; sync_mode='build'             ;;
      -Sd)           opmode='install'; sync_mode='download'          ;;
      -Su)           opmode='upgrade'                                ;;
      -Syu|-Suy)     opmode='upgrade'; sync_mode='install'           ;;
      -Sbu|-Sub)     opmode='upgrade'; sync_mode='build'             ;;
      -Sdu|-Sud)     opmode='upgrade'; sync_mode='download'          ;;
      -Ss)           opmode='search' ; search_mode='search'          ;;
      -Ssq|-Sqs)     opmode='search' ; search_mode='quiet'           ;;
      -Si|-Ssi|-Sis) opmode='search' ; search_mode='info'            ;;
      -Sp|-Ssp|-Sps) opmode='search' ; search_mode='print'           ;;
      --ignore)      shift; ignore_packages+=" $1"                   ;;
      --noconfirm)   noconfirm=true; makepkg_options+=" --noconfirm" ;;
      --nocolor)     set_no_color                                    ;;
      --devel)       devels=true                                     ;;
      --deps)        resolve_dependencies=true                       ;;
      --nodeps)      resolve_dependencies=false                      ;;
      --edit)        edit_pkgbuilds='always'                         ;;
      --noedit)      edit_pkgbuilds='never'                          ;;
      --discard)     discard_sources=true                            ;;
      --nodiscard)   discard_sources=false                           ;;
      --silent)      silent=true                                     ;;
      -h|--help)     message; exit                                   ;;
      --)            shift; arguments+=( "$@" ); return              ;;
      --debug)       :                                               ;;
      --config)      : ; shift                                       ;;
      -*)            warn "unknown option $1, treating as makepkg argument..."
                     makepkg_options+=" $1"                          ;;
      *)             arguments+=( "$1" )                             ;;
    esac

    shift
  done
}

create_temp_directory() {
  debug "storing temporary files in $colorM$temp_directory$nocolor"
  mkdir -p "$temp_directory" || die 'unable to create temp directory'
  rm -rf "$temp_directory"/*
}

enter_build_directory() {
  debug "building in $colorM$build_directory$nocolor"
  mkdir -p "$build_directory" || die 'unable to make build directory'
  cd "$build_directory"       || die 'unable to change to build directory'
}
# }}}

# Search {{{
#
# Perform an AUR search based on $arguments[]. Returns 1 if we're not
# searching.
#
##
perform_search() {
  [[ "$opmode" == 'search' ]] || return 1

  set -- "${arguments[@]}"

  debug "searching for $colorG$*$nocolor (mode: $colorG$search_mode$nocolor)"

  case "$search_mode" in
    search) rpc_search "$*" | sort | print_search ;;
    info)   rpc_info   "$@" | sort | print_info   ;;
    quiet)  rpc_search "$*" | sort | cut -d '|' -f 1 ;;
    print)  for name; do pkgbuild "$name"; done ;;
  esac
}

print_search() {
  local name version description outofdate ood

  while IFS='|' read -r name version description _ outofdate _; do
    (( "$outofdate" )) && ood="$colorR[out of date]$nocolor"

    printf "${colorM}aur/$colorW$name $colorG$version$nocolor $ood\n"
    printf "    $description\n"
  done
}

print_info() {
  local name version description url outofdate ood='No'

  while IFS='|' read -r name version description url outofdate _; do
    (( "$outofdate" )) && ood="${colorR}Yes$nocolor"

    printf "${colorW}Repository  : ${colorM}aur$nocolor\n"
    printf "${colorW}Name        : $name$nocolor\n"
    printf "${colorW}Version     : $colorG$version$nocolor\n"
    printf "${colorW}URL         : $colorC$url$nocolor\n"
    printf "${colorW}Out of date : $nocolor$ood\n"
    printf "${colorW}Description : $nocolor$description\n\n"
  done
}
# }}}

# Add available upgrades {{{
#
# Adds any available upgrades to the front of the $arguments[] array.
# Returns 1 if we're not processing upgrades.
#
##
add_available_upgrades() {
  [[ "$opmode" == 'upgrade' ]] || return 1

  info 'Starting AUR upgrade...'
  arguments=( $(available_upgrades) "${arguments[@]}" )

  (( "${#arguments[@]}" )) || nothing_to_do
}

available_upgrades() {
  local versions name version vers versN check

  declare -A versions

  while read -r name version; do
    versions[$name]=$version
  done < <(pacman -Qm)

  debug "found $colorG${#versions[@]}$nocolor foreign packages to check"

  while IFS='|' read -r name versN _; do
    if is_devel "$name"; then
      $devels && output_upgrade "$name" "development package"
      continue
    fi

    vers="${versions[$name]}"

    read -r check < <(vercmp "$vers" "$versN")

    debug "checking $colorG$name$nocolor ($vers => $versN)"

    (( $check > 0 )) && warn "$name: local ($vers) is newer than aur ($versN)"
    (( $check < 0 )) && output_upgrade "$name" "$vers => $versN"
  done < <(rpc_info "${!versions[@]}")
}

output_upgrade() {
  local name="$1" reason="$2"

  if is_ignored "$name"; then
    warn "$name: ignoring package upgrade ($reason)"
  else
    debug "will upgrade $colorG$name$nocolor ($reason)"
    printf "$name\n"
  fi
}
# }}}

# Resolve dependencies {{{
#
# Resolves dependencies for $arguments[] and places them in the
# $dependencies[] array. Returns 1 if we're not resolving dependencies.
#
##
resolve_dependencies() {
  $resolve_dependencies || return 1

  info 'Resolving dependencies...'
  create_temp_directory
  resolve "${arguments[@]}"
}

resolve() {
  local name dep

  for name; do
    if source_pkgbuild "$name"; then
      depends=($(pacman -T -- ${depends[@]} ${makedepends[@]}))
      depends=("${depends[@]%>*}")
      depends=("${depends[@]%=*}")
      depends=("${depends[@]%<*}")

      for dep in "${depends[@]}"; do
        resolve "$dep"
      done

      [[ " ${arguments[*]} " =~ " $name " ]] || dependencies=( "$name" "${dependencies[@]}" )
    fi
  done
}

source_pkgbuild() {
  local name="$1" pkgbuild="$temp_directory/${1}_PKGBUILD"

  if [[ ! -f "$pkgbuild" ]]; then
    if pkgbuild "$name" > "$pkgbuild"; then
      debug "PKGBUILD found for $colorG$name$nocolor"

      if prompt_to_edit "$name" "$pkgbuild"; then
        debug "executing ${colorY}source $pkgbuild$nocolor"
        source "$pkgbuild"
        return 0
      fi
    else
      debug "PKGBUILD ${colorR}not found$nocolor for $colorG$name$nocolor"
    fi
  fi

  touch "$pkgbuild"
  return 1
}
# }}}

# Setup targets {{{
#
# For each package in the $dependencies[] and $arguments[] arrays,
# ensure they are available in the AUR, handle ignored packages, and
# populate the $targets[], $target_versions[], and $target_deps[] arrays
# for later processing.
#
###
setup_targets() {
  local name version versions

  declare -A versions

  set -- "${dependencies[@]}" "${arguments[@]}"

  (( "$#" )) || die 'no targets specified (use -h for help)'

  debug "setting up $colorG$#$nocolor targets for processing"

  info 'Searching AUR...'

  while IFS='|' read -r name version _; do
    debug "found $colorG$name$nocolor in the AUR at version $colorG$version$nocolor"
    versions[$name]=$version
  done < <(rpc_info "$@")

  for name; do
    version="${versions[$name]}"

    [[ -z "$version" ]] && die "target not found: $name"

    if is_ignored "$name"; then
      if ! prompt "$name is in ignore_packages. Install anyway"; then
        warn "skipping target: $name"
        continue
      fi
    fi

    targets+=( "$name" )
    target_versions[$name]=$version
  done

  (( "${#targets[@]}" )) || nothing_to_do

  prompt_to_install "${targets[@]}"

  for name in "${dependencies[@]}"; do target_deps[$name]=1; done
  for name in "${arguments[@]}";    do target_deps[$name]=0; done
}
# }}}

# Process targets {{{
#
# For each entry in the $targets[] array, download, build, or install it
# based on the current sync_mode. Uses $target_deps[] to know if the
# package is a dependency or not.
#
###
process_targets() {
  local name

  set -- "${targets[@]}"

  [[ "$sync_mode" == 'install' ]] && makepkg_options+=' --install'

  debug "processing $colorG$#$nocolor targets"

  enter_build_directory

  for name; do
    info 'Retrieving taurball from AUR...'

    if [[ "$sync_mode" == 'download' ]]; then
      debug "downloading $colorG$name$nocolor to filesystem"

      if ! taurball "$name" > "${name}.tar.gz"; then
        warn "$name: failed to retrieve aur sources"
        continue
      fi
    else
      debug "extracting $colorG$name$nocolor directly"

      if ! taurball "$name" | tar xfz -; then
        warn "$name: failed to retrieve aur sources"
        continue
      fi

      build_target "$name" && discard_sources "$name"
    fi
  done
}

build_target() {
  local name="$1" pkgbuild ret=0

  info 'Building package...'

  debug "building $colorG$name${nocolor}..."

  cd "$name" || die 'unable to change to source directory'

  if [[ -f "/etc/customizepkg.d/$name" ]]; then
    info 'Calling customizepkg...'
    customizepkg --modify || warn "customizepkg returned non-zero ($?)"
  fi

  if prompt_to_edit "$name" './PKGBUILD' 'building'; then
    if (( ${target_deps[$name]} )); then
      debug "executing $colorY$makepkg $makepkg_options --asdeps$nocolor"
      buildpkg --asdeps || die "dependency package $name failed to build, aborting"
    else
      buildpkg || { ret=1; warn "package $name failed to build, skipping"; }
    fi
  fi

  cd .. || die 'unable to change out of source directory'

  debug "build finished, returning $colorG$ret$nocolor"

  return $ret
}

discard_sources() {
  local name="$1"

  if ! $discard_sources; then
    debug "keeping sources for $colorG$name$nocolor (discard false)"
    return
  fi

  if $keep_devels && is_devel "$name"; then
    debug "keeping sources for $colorG$name$nocolor (development package)"
    return
  fi

  info 'Discarding sources...'

  debug "executing ${colorY}rm -rf ./$name$nocolor"

  rm -rf "./$name"
}
# }}}

declare -a arguments
declare -a dependencies
declare -a targets
declare -A target_versions # name->version
declare -A target_deps     # name->is-dep?

set_defaults "$@"
source_config

[[ ! -t 1 ]] && set_no_color

parse_options "$@"

perform_search || {
  add_available_upgrades
  resolve_dependencies
  setup_targets
  process_targets
}
